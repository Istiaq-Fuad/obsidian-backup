### Idea

Instead of creating objects using `new` directly, you delegate the creation to a **factory method**.  
This is useful when the exact type of object is decided at runtime.

### When to use

When you have a common interface and multiple implementations, and you want to decide which implementation to create dynamically.

### Example

Suppose we are creating different types of notifications.

### Step 1: Common interface

```java
interface Notification {
    void notifyUser();
}
```

### Step 2: Concrete implementations

```java
class EmailNotification implements Notification {
    public void notifyUser() {
        System.out.println("Sending Email Notification");
    }
}

class SMSNotification implements Notification {
    public void notifyUser() {
        System.out.println("Sending SMS Notification");
    }
}
```

### Step 3: Factory class

```java
class NotificationFactory {
    public static Notification createNotification(String type) {
        if (type.equalsIgnoreCase("EMAIL")) {
            return new EmailNotification();
        } else if (type.equalsIgnoreCase("SMS")) {
            return new SMSNotification();
        }
        return null;
    }
}
```

### Step 4: Usage

```java
public class Main {
    public static void main(String[] args) {
        Notification notification =
                NotificationFactory.createNotification("EMAIL");
        notification.notifyUser();
    }
}
```

### Key point

The client does **not know** the concrete class name. Object creation logic is centralized.

 

---

## Quick Summary

|Pattern|Purpose|
|---|---|
|Factory Method|Create one object without exposing instantiation logic|
|Abstract Factory|Create families of related objects|
|Singleton|Ensure only one instance|
|Builder|Build complex objects step by step|

If you want, next I can **compare Factory vs Abstract Factory**, or explain **real-world use cases**, or give **UML diagrams** for exam preparation.